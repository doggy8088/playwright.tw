"use strict";(self.webpackChunkplaywright_dev=self.webpackChunkplaywright_dev||[]).push([[4198],{9518:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>d,toc:()=>u});var o=t(4848),s=t(8453),a=t(4235),r=t(8328),i=(t(3078),t(4562));const l={id:"test-components",title:"Components (experimental)"},c=void 0,d={id:"test-components",title:"Components (experimental)",description:"Introduction",source:"@site/docs/test-components.mdx",sourceDirName:".",slug:"/test-components",permalink:"/docs/next/test-components",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"test-components",title:"Components (experimental)"},sidebar:"docs",previous:{title:"Clock",permalink:"/docs/next/clock"},next:{title:"Debugging Tests",permalink:"/docs/next/debug"}},p={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Example",id:"example",level:2},{value:"How to get started",id:"how-to-get-started",level:2},{value:"Step 1: Install Playwright Test for components for your respective framework",id:"step-1-install-playwright-test-for-components-for-your-respective-framework",level:3},{value:"Step 2. Create a test file <code>src/App.spec.{ts,tsx}</code>",id:"step-2-create-a-test-file-srcappspectstsx",level:3},{value:"Step 3. Run the tests",id:"step-3-run-the-tests",level:3},{value:"Further reading: configure reporting, browsers, tracing",id:"further-reading-configure-reporting-browsers-tracing",level:3},{value:"Test stories",id:"test-stories",level:2},{value:"Under the hood",id:"under-the-hood",level:2},{value:"API reference",id:"api-reference",level:2},{value:"props",id:"props",level:3},{value:"callbacks / events",id:"callbacks--events",level:3},{value:"children / slots",id:"children--slots",level:3},{value:"hooks",id:"hooks",level:3},{value:"unmount",id:"unmount",level:3},{value:"update",id:"update",level:3},{value:"Handling network requests",id:"handling-network-requests",level:3},{value:"Frequently asked questions",id:"frequently-asked-questions",level:2},{value:"What&#39;s the difference between <code>@playwright/test</code> and <code>@playwright/experimental-ct-{react,svelte,vue,solid}</code>?",id:"whats-the-difference-between-playwrighttest-and-playwrightexperimental-ct-reactsveltevuesolid",level:3},{value:"I have a project that already uses Vite. Can I reuse the config?",id:"i-have-a-project-that-already-uses-vite-can-i-reuse-the-config",level:3},{value:"How can I test components that uses Pinia?",id:"how-can-i-test-components-that-uses-pinia",level:3},{value:"How do I access the component&#39;s methods or its instance?",id:"how-do-i-access-the-components-methods-or-its-instance",level:3}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.p,{children:"Playwright Test can now test your components."}),"\n",(0,o.jsx)(i.A,{id:"y3YxX4sFJbM",title:"Component testing"}),"\n",(0,o.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,o.jsx)(n.p,{children:"Here is what a typical component test looks like:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('event should work', async ({ mount }) => {\n  let clicked = false;\n\n  // Mount a component. Returns locator pointing to the component.\n  const component = await mount(\n    <Button title=\"Submit\" onClick={() => { clicked = true }}></Button>\n  );\n\n  // As with any Playwright test, assert locator text.\n  await expect(component).toContainText('Submit');\n\n  // Perform locator click. This will trigger the event.\n  await component.click();\n\n  // Assert that respective events have been fired.\n  expect(clicked).toBeTruthy();\n});\n"})}),"\n",(0,o.jsx)(n.h2,{id:"how-to-get-started",children:"How to get started"}),"\n",(0,o.jsx)(n.p,{children:"Adding Playwright Test to an existing project is easy. Below are the steps to enable Playwright Test for a React, Vue, Svelte or Solid project."}),"\n",(0,o.jsx)(n.h3,{id:"step-1-install-playwright-test-for-components-for-your-respective-framework",children:"Step 1: Install Playwright Test for components for your respective framework"}),"\n",(0,o.jsxs)(a.A,{defaultValue:"npm",values:[{label:"npm",value:"npm"},{label:"yarn",value:"yarn"},{label:"pnpm",value:"pnpm"}],children:[(0,o.jsx)(r.A,{value:"npm",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"npm init playwright@latest -- --ct\n"})})}),(0,o.jsx)(r.A,{value:"yarn",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"yarn create playwright --ct\n"})})}),(0,o.jsx)(r.A,{value:"pnpm",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"pnpm create playwright --ct\n"})})})]}),"\n",(0,o.jsx)(n.p,{children:"This step creates several files in your workspace:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",metastring:'title="playwright/index.html"',children:'<html lang="en">\n  <body>\n    <div id="root"></div>\n    <script type="module" src="./index.ts"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This file defines an html file that will be used to render components during testing. It must contain element with ",(0,o.jsx)(n.code,{children:'id="root"'}),", that's where components are mounted. It must also link the script called ",(0,o.jsx)(n.code,{children:"playwright/index.{js,ts,jsx,tsx}"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["You can include stylesheets, apply theme and inject code into the page where component is mounted using this script. It can be either a ",(0,o.jsx)(n.code,{children:".js"}),", ",(0,o.jsx)(n.code,{children:".ts"}),", ",(0,o.jsx)(n.code,{children:".jsx"})," or ",(0,o.jsx)(n.code,{children:".tsx"})," file."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="playwright/index.ts"',children:"// Apply theme here, add anything your component needs at runtime here.\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"step-2-create-a-test-file-srcappspectstsx",children:["Step 2. Create a test file ",(0,o.jsx)(n.code,{children:"src/App.spec.{ts,tsx}"})]}),"\n",(0,o.jsxs)(a.A,{defaultValue:"react",values:[{label:"React",value:"react"},{label:"Solid",value:"solid"},{label:"Svelte",value:"svelte"},{label:"Vue",value:"vue"}],children:[(0,o.jsx)(r.A,{value:"react",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { test, expect } from '@playwright/experimental-ct-react';\nimport App from './App';\n\ntest.use({ viewport: { width: 500, height: 500 } });\n\ntest('should work', async ({ mount }) => {\n  const component = await mount(<App />);\n  await expect(component).toContainText('Learn React');\n});\n"})})}),(0,o.jsxs)(r.A,{value:"vue",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { test, expect } from '@playwright/experimental-ct-vue';\nimport App from './App.vue';\n\ntest.use({ viewport: { width: 500, height: 500 } });\n\ntest('should work', async ({ mount }) => {\n  const component = await mount(App);\n  await expect(component).toContainText('Vite + Vue');\n});\n"})}),(0,o.jsxs)(n.p,{children:["If using TypeScript and Vue make sure to add a ",(0,o.jsx)(n.code,{children:"vue.d.ts"})," file to your project:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"declare module '*.vue';\n"})})]}),(0,o.jsx)(r.A,{value:"svelte",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { test, expect } from '@playwright/experimental-ct-svelte';\nimport App from './App.svelte';\n\ntest.use({ viewport: { width: 500, height: 500 } });\n\ntest('should work', async ({ mount }) => {\n  const component = await mount(App);\n  await expect(component).toContainText('Vite + Svelte');\n});\n"})})}),(0,o.jsx)(r.A,{value:"solid",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { test, expect } from '@playwright/experimental-ct-solid';\nimport App from './App';\n\ntest.use({ viewport: { width: 500, height: 500 } });\n\ntest('should work', async ({ mount }) => {\n  const component = await mount(<App />);\n  await expect(component).toContainText('Learn Solid');\n});\n"})})})]}),"\n",(0,o.jsx)(n.h3,{id:"step-3-run-the-tests",children:"Step 3. Run the tests"}),"\n",(0,o.jsxs)(n.p,{children:["You can run tests using the ",(0,o.jsx)(n.a,{href:"/docs/next/getting-started-vscode",children:"VS Code extension"})," or the command line."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sh",children:"npm run test-ct\n"})}),"\n",(0,o.jsx)(n.h3,{id:"further-reading-configure-reporting-browsers-tracing",children:"Further reading: configure reporting, browsers, tracing"}),"\n",(0,o.jsxs)(n.p,{children:["Refer to ",(0,o.jsx)(n.a,{href:"/docs/next/test-configuration",children:"Playwright config"})," for configuring your project."]}),"\n",(0,o.jsx)(n.h2,{id:"test-stories",children:"Test stories"}),"\n",(0,o.jsx)(n.p,{children:"When Playwright Test is used to test web components, tests run in Node.js, while components run in the real browser. This brings together the best of both worlds: components run in the real browser environment, real clicks are triggered, real layout is executed, visual regression is possible. At the same time, test can use all the powers of Node.js as well as all the Playwright Test features. As a result, the same parallel, parametrized tests with the same post-mortem Tracing story are available during component testing."}),"\n",(0,o.jsx)(n.p,{children:"This however, is introducing a number of limitations:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"You can't pass complex live objects to your component. Only plain JavaScript objects and built-in types like strings, numbers, dates etc. can be passed."}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('this will work', async ({ mount }) => {\n  const component = await mount(<ProcessViewer process={{ name: 'playwright' }}/>);\n});\n\ntest('this will not work', async ({ mount }) => {\n  // `process` is a Node object, we can't pass it to the browser and expect it to work.\n  const component = await mount(<ProcessViewer process={process}/>);\n});\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"You can't pass data to your component synchronously in a callback:"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('this will not work', async ({ mount }) => {\n  // () => 'red' callback lives in Node. If `ColorPicker` component in the browser calls the parameter function\n  // `colorGetter` it won't get result synchronously. It'll be able to get it via await, but that is not how\n  // components are typically built.\n  const component = await mount(<ColorPicker colorGetter={() => 'red'}/>);\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"Working around these and other limitations is quick and elegant: for every use case of the tested component, create a wrapper of this component designed specifically for test. Not only it will mitigate the limitations, but it will also offer powerful abstractions for testing where you would be able to define environment, theme and other aspects of your component rendering."}),"\n",(0,o.jsx)(n.p,{children:"Let's say you'd like to test following component:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="input-media.tsx"',children:"import React from 'react';\n\ntype InputMediaProps = {\n  // Media is a complex browser object we can't send to Node while testing.\n  onChange(media: Media): void;\n};\n\nexport function InputMedia(props: InputMediaProps) {\n  return <></> as any;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Create a story file for your component:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="input-media.story.tsx"',children:"import React from 'react';\nimport InputMedia from './import-media';\n\ntype InputMediaForTestProps = {\n  onMediaChange(mediaName: string): void;\n};\n\nexport function InputMediaForTest(props: InputMediaForTestProps) {\n  // Instead of sending a complex `media` object to the test, send the media name.\n  return <InputMedia onChange={media => props.onMediaChange(media.name)} />;\n}\n// Export more stories here.\n"})}),"\n",(0,o.jsx)(n.p,{children:"Then test the component via testing the story:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="input-media.test.spec.tsx"',children:"test('changes the image', async ({ mount }) => {\n  let mediaSelected: string | null = null;\n\n  const component = await mount(\n    <InputMediaForTest\n      onMediaChange={mediaName => {\n        mediaSelected = mediaName;\n      }}\n    />\n  );\n  await component\n    .getByTestId('imageInput')\n    .setInputFiles('src/assets/logo.png');\n\n  await expect(component.getByAltText(/selected image/i)).toBeVisible();\n  await expect.poll(() => mediaSelected).toBe('logo.png');\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:'As a result, for every component you\'ll have a story file that exports all the stories that are actually tested. These stories live in the browser and "convert" complex object into the simple objects that can be accessed in the test.'}),"\n",(0,o.jsx)(n.h2,{id:"under-the-hood",children:"Under the hood"}),"\n",(0,o.jsx)(n.p,{children:"Here is how component testing works:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Once the tests are executed, Playwright creates a list of components that the tests need."}),"\n",(0,o.jsx)(n.li,{children:"It then compiles a bundle that includes these components and serves it using a local static web server."}),"\n",(0,o.jsxs)(n.li,{children:["Upon the ",(0,o.jsx)(n.code,{children:"mount"})," call within the test, Playwright navigates to the facade page ",(0,o.jsx)(n.code,{children:"/playwright/index.html"})," of this bundle and tells it to render the component."]}),"\n",(0,o.jsx)(n.li,{children:"Events are marshalled back to the Node.js environment to allow verification."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Playwright is using ",(0,o.jsx)(n.a,{href:"https://vitejs.dev/",children:"Vite"})," to create the components bundle and serve it."]}),"\n",(0,o.jsx)(n.h2,{id:"api-reference",children:"API reference"}),"\n",(0,o.jsx)(n.h3,{id:"props",children:"props"}),"\n",(0,o.jsx)(n.p,{children:"Provide props to a component when mounted."}),"\n",(0,o.jsxs)(a.A,{defaultValue:"react",values:[{label:"React",value:"react"},{label:"Solid",value:"solid"},{label:"Svelte",value:"svelte"},{label:"Vue",value:"vue"}],children:[(0,o.jsx)(r.A,{value:"react",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('props', async ({ mount }) => {\n  const component = await mount(<Component msg=\"greetings\" />);\n});\n"})})}),(0,o.jsx)(r.A,{value:"solid",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('props', async ({ mount }) => {\n  const component = await mount(<Component msg=\"greetings\" />);\n});\n"})})}),(0,o.jsx)(r.A,{value:"svelte",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('props', async ({ mount }) => {\n  const component = await mount(Component, { props: { msg: 'greetings' } });\n});\n"})})}),(0,o.jsx)(r.A,{value:"vue",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('props', async ({ mount }) => {\n  const component = await mount(Component, { props: { msg: 'greetings' } });\n});\n"})})})]}),"\n",(0,o.jsx)(n.h3,{id:"callbacks--events",children:"callbacks / events"}),"\n",(0,o.jsx)(n.p,{children:"Provide callbacks/events to a component when mounted."}),"\n",(0,o.jsxs)(a.A,{defaultValue:"react",values:[{label:"React",value:"react"},{label:"Solid",value:"solid"},{label:"Svelte",value:"svelte"},{label:"Vue",value:"vue"}],children:[(0,o.jsx)(r.A,{value:"react",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('callback', async ({ mount }) => {\n  const component = await mount(<Component callback={() => {}} />);\n});\n"})})}),(0,o.jsx)(r.A,{value:"solid",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('callback', async ({ mount }) => {\n  const component = await mount(<Component callback={() => {}} />);\n});\n"})})}),(0,o.jsx)(r.A,{value:"svelte",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('event', async ({ mount }) => {\n  const component = await mount(Component, { on: { callback() {} } });\n});\n"})})}),(0,o.jsx)(r.A,{value:"vue",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('event', async ({ mount }) => {\n  const component = await mount(Component, { on: { callback() {} } });\n});\n"})})})]}),"\n",(0,o.jsx)(n.h3,{id:"children--slots",children:"children / slots"}),"\n",(0,o.jsx)(n.p,{children:"Provide children/slots to a component when mounted."}),"\n",(0,o.jsxs)(a.A,{defaultValue:"react",values:[{label:"React",value:"react"},{label:"Solid",value:"solid"},{label:"Svelte",value:"svelte"},{label:"Vue",value:"vue"}],children:[(0,o.jsx)(r.A,{value:"react",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('children', async ({ mount }) => {\n  const component = await mount(<Component>Child</Component>);\n});\n"})})}),(0,o.jsx)(r.A,{value:"solid",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('children', async ({ mount }) => {\n  const component = await mount(<Component>Child</Component>);\n});\n"})})}),(0,o.jsx)(r.A,{value:"svelte",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('slot', async ({ mount }) => {\n  const component = await mount(Component, { slots: { default: 'Slot' } });\n});\n"})})}),(0,o.jsx)(r.A,{value:"vue",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('slot', async ({ mount }) => {\n  const component = await mount(Component, { slots: { default: 'Slot' } });\n});\n"})})})]}),"\n",(0,o.jsx)(n.h3,{id:"hooks",children:"hooks"}),"\n",(0,o.jsxs)(n.p,{children:["You can use ",(0,o.jsx)(n.code,{children:"beforeMount"})," and ",(0,o.jsx)(n.code,{children:"afterMount"})," hooks to configure your app. This lets you set up things like your app router, fake server etc. giving you the flexibility you need. You can also pass custom configuration from the ",(0,o.jsx)(n.code,{children:"mount"})," call from a test, which is accessible from the ",(0,o.jsx)(n.code,{children:"hooksConfig"})," fixture. This includes any config that needs to be run before or after mounting the component. An example of configuring a router is provided below:"]}),"\n",(0,o.jsxs)(a.A,{defaultValue:"react",values:[{label:"React",value:"react"},{label:"Solid",value:"solid"},{label:"Vue3",value:"vue3"},{label:"Vue2",value:"vue2"}],children:[(0,o.jsxs)(r.A,{value:"react",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="playwright/index.tsx"',children:"import { beforeMount, afterMount } from '@playwright/experimental-ct-react/hooks';\nimport { BrowserRouter } from 'react-router-dom';\n\nexport type HooksConfig = {\n  enableRouting?: boolean;\n}\n\nbeforeMount<HooksConfig>(async ({ App, hooksConfig }) => {\n  if (hooksConfig?.enableRouting)\n    return <BrowserRouter><App /></BrowserRouter>;\n});\n"})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="src/pages/ProductsPage.spec.tsx"',children:"import { test, expect } from '@playwright/experimental-ct-react';\nimport type { HooksConfig } from '../playwright';\nimport { ProductsPage } from './pages/ProductsPage';\n\ntest('configure routing through hooks config', async ({ page, mount }) => {\n  const component = await mount<HooksConfig>(<ProductsPage />, {\n    hooksConfig: { enableRouting: true },\n  });\n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');\n});\n"})})]}),(0,o.jsxs)(r.A,{value:"solid",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="playwright/index.tsx"',children:"import { beforeMount, afterMount } from '@playwright/experimental-ct-solid/hooks';\nimport { Router } from '@solidjs/router';\n\nexport type HooksConfig = {\n  enableRouting?: boolean;\n}\n\nbeforeMount<HooksConfig>(async ({ App, hooksConfig }) => {\n  if (hooksConfig?.enableRouting)\n    return <Router><App /></Router>;\n});\n"})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="src/pages/ProductsPage.spec.tsx"',children:"import { test, expect } from '@playwright/experimental-ct-solid';\nimport type { HooksConfig } from '../playwright';\nimport { ProductsPage } from './pages/ProductsPage';\n\ntest('configure routing through hooks config', async ({ page, mount }) => {\n  const component = await mount<HooksConfig>(<ProductsPage />, {\n    hooksConfig: { enableRouting: true },\n  });\n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');\n});\n"})})]}),(0,o.jsxs)(r.A,{value:"vue3",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="playwright/index.ts"',children:"import { beforeMount, afterMount } from '@playwright/experimental-ct-vue/hooks';\nimport { router } from '../src/router';\n\nexport type HooksConfig = {\n  enableRouting?: boolean;\n}\n\nbeforeMount<HooksConfig>(async ({ app, hooksConfig }) => {\n  if (hooksConfig?.enableRouting)\n    app.use(router);\n});\n"})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="src/pages/ProductsPage.spec.ts"',children:"import { test, expect } from '@playwright/experimental-ct-vue';\nimport type { HooksConfig } from '../playwright';\nimport ProductsPage from './pages/ProductsPage.vue';\n\ntest('configure routing through hooks config', async ({ page, mount }) => {\n  const component = await mount<HooksConfig>(ProductsPage, {\n    hooksConfig: { enableRouting: true },\n  });\n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');\n});\n"})})]}),(0,o.jsxs)(r.A,{value:"vue2",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="playwright/index.ts"',children:"import { beforeMount, afterMount } from '@playwright/experimental-ct-vue2/hooks';\nimport Router from 'vue-router';\nimport { router } from '../src/router';\n\nexport type HooksConfig = {\n  enableRouting?: boolean;\n}\n\nbeforeMount<HooksConfig>(async ({ app, hooksConfig }) => {\n  if (hooksConfig?.enableRouting) {\n    Vue.use(Router);\n    return { router }\n  }\n});\n"})}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="src/pages/ProductsPage.spec.ts"',children:"import { test, expect } from '@playwright/experimental-ct-vue2';\nimport type { HooksConfig } from '../playwright';\nimport ProductsPage from './pages/ProductsPage.vue';\n\ntest('configure routing through hooks config', async ({ page, mount }) => {\n  const component = await mount<HooksConfig>(ProductsPage, {\n    hooksConfig: { enableRouting: true },\n  });\n  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');\n});\n"})})]})]}),"\n",(0,o.jsx)(n.h3,{id:"unmount",children:"unmount"}),"\n",(0,o.jsx)(n.p,{children:'Unmount the mounted component from the DOM. This is useful for testing the component\'s behavior upon unmounting. Use cases include testing an "Are you sure you want to leave?" modal or ensuring proper cleanup of event handlers to prevent memory leaks.'}),"\n",(0,o.jsxs)(a.A,{defaultValue:"react",values:[{label:"React",value:"react"},{label:"Solid",value:"solid"},{label:"Svelte",value:"svelte"},{label:"Vue",value:"vue"}],children:[(0,o.jsx)(r.A,{value:"react",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('unmount', async ({ mount }) => {\n  const component = await mount(<Component/>);\n  await component.unmount();\n});\n"})})}),(0,o.jsx)(r.A,{value:"solid",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('unmount', async ({ mount }) => {\n  const component = await mount(<Component/>);\n  await component.unmount();\n});\n"})})}),(0,o.jsx)(r.A,{value:"svelte",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('unmount', async ({ mount }) => {\n  const component = await mount(Component);\n  await component.unmount();\n});\n"})})}),(0,o.jsx)(r.A,{value:"vue",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('unmount', async ({ mount }) => {\n  const component = await mount(Component);\n  await component.unmount();\n});\n"})})})]}),"\n",(0,o.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,o.jsx)(n.p,{children:"Update props, slots/children, and/or events/callbacks of a mounted component. These component inputs can change at any time and are typically provided by the parent component, but sometimes it is necessary to ensure that your components behave appropriately to new inputs."}),"\n",(0,o.jsxs)(a.A,{defaultValue:"react",values:[{label:"React",value:"react"},{label:"Solid",value:"solid"},{label:"Svelte",value:"svelte"},{label:"Vue",value:"vue"}],children:[(0,o.jsx)(r.A,{value:"react",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('update', async ({ mount }) => {\n  const component = await mount(<Component/>);\n  await component.update(\n      <Component msg=\"greetings\" callback={() => {}}>Child</Component>\n  );\n});\n"})})}),(0,o.jsx)(r.A,{value:"solid",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('update', async ({ mount }) => {\n  const component = await mount(<Component/>);\n  await component.update(\n      <Component msg=\"greetings\" callback={() => {}}>Child</Component>\n  );\n});\n"})})}),(0,o.jsx)(r.A,{value:"svelte",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('update', async ({ mount }) => {\n  const component = await mount(Component);\n  await component.update({\n    props: { msg: 'greetings' },\n    on: { callback: () => {} },\n    slots: { default: 'Child' }\n  });\n});\n"})})}),(0,o.jsx)(r.A,{value:"vue",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('update', async ({ mount }) => {\n  const component = await mount(Component);\n  await component.update({\n    props: { msg: 'greetings' },\n    on: { callback: () => {} },\n    slots: { default: 'Child' }\n  });\n});\n"})})})]}),"\n",(0,o.jsx)(n.h3,{id:"handling-network-requests",children:"Handling network requests"}),"\n",(0,o.jsxs)(n.p,{children:["Playwright provides an ",(0,o.jsx)(n.strong,{children:"experimental"})," ",(0,o.jsx)(n.code,{children:"router"})," fixture to intercept and handle network requests. There are two ways to use the ",(0,o.jsx)(n.code,{children:"router"})," fixture:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Call ",(0,o.jsx)(n.code,{children:"router.route(url, handler)"})," that behaves similarly to ",(0,o.jsx)(n.a,{href:"/docs/next/api/class-page#page-route",children:"page.route()"}),". See the ",(0,o.jsx)(n.a,{href:"/docs/next/mock",children:"network mocking guide"})," for more details."]}),"\n",(0,o.jsxs)(n.li,{children:["Call ",(0,o.jsx)(n.code,{children:"router.use(handlers)"})," and pass ",(0,o.jsx)(n.a,{href:"https://mswjs.io/",children:"MSW library"})," request handlers to it."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Here is an example of reusing your existing MSW handlers in the test."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { handlers } from '@src/mocks/handlers';\n\ntest.beforeEach(async ({ router }) => {\n  // install common handlers before each test\n  await router.use(...handlers);\n});\n\ntest('example test', async ({ mount }) => {\n  // test as usual, your handlers are active\n  // ...\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"You can also introduce a one-off handler for a specific test."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { http, HttpResponse } from 'msw';\n\ntest('example test', async ({ mount, router }) => {\n  await router.use(http.get('/data', async ({ request }) => {\n    return HttpResponse.json({ value: 'mocked' });\n  }));\n\n  // test as usual, your handler is active\n  // ...\n});\n"})}),"\n",(0,o.jsx)(n.h2,{id:"frequently-asked-questions",children:"Frequently asked questions"}),"\n",(0,o.jsxs)(n.h3,{id:"whats-the-difference-between-playwrighttest-and-playwrightexperimental-ct-reactsveltevuesolid",children:["What's the difference between ",(0,o.jsx)(n.code,{children:"@playwright/test"})," and ",(0,o.jsx)(n.code,{children:"@playwright/experimental-ct-{react,svelte,vue,solid}"}),"?"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"test('\u2026', async ({ mount, page, context }) => {\n  // \u2026\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"@playwright/experimental-ct-{react,svelte,vue,solid}"})," wrap ",(0,o.jsx)(n.code,{children:"@playwright/test"})," to provide an additional built-in component-testing specific fixture called ",(0,o.jsx)(n.code,{children:"mount"}),":"]}),"\n",(0,o.jsxs)(a.A,{defaultValue:"react",values:[{label:"React",value:"react"},{label:"Solid",value:"solid"},{label:"Svelte",value:"svelte"},{label:"Vue",value:"vue"}],children:[(0,o.jsx)(r.A,{value:"react",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { test, expect } from '@playwright/experimental-ct-react';\nimport HelloWorld from './HelloWorld';\n\ntest.use({ viewport: { width: 500, height: 500 } });\n\ntest('should work', async ({ mount }) => {\n  const component = await mount(<HelloWorld msg=\"greetings\" />);\n  await expect(component).toContainText('Greetings');\n});\n"})})}),(0,o.jsx)(r.A,{value:"vue",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { test, expect } from '@playwright/experimental-ct-vue';\nimport HelloWorld from './HelloWorld.vue';\n\ntest.use({ viewport: { width: 500, height: 500 } });\n\ntest('should work', async ({ mount }) => {\n  const component = await mount(HelloWorld, {\n    props: {\n      msg: 'Greetings',\n    },\n  });\n  await expect(component).toContainText('Greetings');\n});\n"})})}),(0,o.jsx)(r.A,{value:"svelte",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { test, expect } from '@playwright/experimental-ct-svelte';\nimport HelloWorld from './HelloWorld.svelte';\n\ntest.use({ viewport: { width: 500, height: 500 } });\n\ntest('should work', async ({ mount }) => {\n  const component = await mount(HelloWorld, {\n    props: {\n      msg: 'Greetings',\n    },\n  });\n  await expect(component).toContainText('Greetings');\n});\n"})})}),(0,o.jsx)(r.A,{value:"solid",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { test, expect } from '@playwright/experimental-ct-solid';\nimport HelloWorld from './HelloWorld';\n\ntest.use({ viewport: { width: 500, height: 500 } });\n\ntest('should work', async ({ mount }) => {\n  const component = await mount(<HelloWorld msg=\"greetings\" />);\n  await expect(component).toContainText('Greetings');\n});\n"})})})]}),"\n",(0,o.jsxs)(n.p,{children:["Additionally, it adds some config options you can use in your ",(0,o.jsx)(n.code,{children:"playwright-ct.config.{ts,js}"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Finally, under the hood, each test re-uses the ",(0,o.jsx)(n.code,{children:"context"})," and ",(0,o.jsx)(n.code,{children:"page"})," fixture as a speed optimization for Component Testing. It resets them in between each test so it should be functionally equivalent to ",(0,o.jsx)(n.code,{children:"@playwright/test"}),"'s guarantee that you get a new, isolated ",(0,o.jsx)(n.code,{children:"context"})," and ",(0,o.jsx)(n.code,{children:"page"})," fixture per-test."]}),"\n",(0,o.jsx)(n.h3,{id:"i-have-a-project-that-already-uses-vite-can-i-reuse-the-config",children:"I have a project that already uses Vite. Can I reuse the config?"}),"\n",(0,o.jsxs)(n.p,{children:["At this point, Playwright is bundler-agnostic, so it is not reusing your existing Vite config. Your config might have a lot of things we won't be able to reuse. So for now, you would copy your path mappings and other high level settings into the ",(0,o.jsx)(n.code,{children:"ctViteConfig"})," property of Playwright config."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { defineConfig } from '@playwright/experimental-ct-react';\n\nexport default defineConfig({\n  use: {\n    ctViteConfig: {\n      // ...\n    },\n  },\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can specify plugins via Vite config for testing settings. Note that once you start specifying plugins, you are responsible for specifying the framework plugin as well, ",(0,o.jsx)(n.code,{children:"vue()"})," in this case:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { defineConfig, devices } from '@playwright/experimental-ct-vue';\n\nimport { resolve } from 'path';\nimport vue from '@vitejs/plugin-vue';\nimport AutoImport from 'unplugin-auto-import/vite';\nimport Components from 'unplugin-vue-components/vite';\n\nexport default defineConfig({\n  testDir: './tests/component',\n  use: {\n    trace: 'on-first-retry',\n    ctViteConfig: {\n      plugins: [\n        vue(),\n        AutoImport({\n          imports: [\n            'vue',\n            'vue-router',\n            '@vueuse/head',\n            'pinia',\n            {\n              '@/store': ['useStore'],\n            },\n          ],\n          dts: 'src/auto-imports.d.ts',\n          eslintrc: {\n            enabled: true,\n          },\n        }),\n        Components({\n          dirs: ['src/components'],\n          extensions: ['vue'],\n        }),\n      ],\n      resolve: {\n        alias: {\n          '@': resolve(__dirname, './src'),\n        },\n      },\n    },\n  },\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"how-can-i-test-components-that-uses-pinia",children:"How can I test components that uses Pinia?"}),"\n",(0,o.jsxs)(n.p,{children:["Pinia needs to be initialized in ",(0,o.jsx)(n.code,{children:"playwright/index.{js,ts,jsx,tsx}"}),". If you do this inside a ",(0,o.jsx)(n.code,{children:"beforeMount"})," hook, the ",(0,o.jsx)(n.code,{children:"initialState"})," can be overwritten on a per-test basis:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="playwright/index.ts"',children:"import { beforeMount, afterMount } from '@playwright/experimental-ct-vue/hooks';\nimport { createTestingPinia } from '@pinia/testing';\nimport type { StoreState } from 'pinia';\nimport type { useStore } from '../src/store';\n\nexport type HooksConfig = {\n  store?: StoreState<ReturnType<typeof useStore>>;\n}\n\nbeforeMount<HooksConfig>(async ({ hooksConfig }) => {\n  createTestingPinia({\n    initialState: hooksConfig?.store,\n    /**\n     * Use http intercepting to mock api calls instead:\n     * https://playwright.dev/docs/mock#mock-api-requests\n     */\n    stubActions: false,\n    createSpy(args) {\n      console.log('spy', args)\n      return () => console.log('spy-returns')\n    },\n  });\n});\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",metastring:'title="src/pinia.spec.ts"',children:"import { test, expect } from '@playwright/experimental-ct-vue';\nimport type { HooksConfig } from '../playwright';\nimport Store from './Store.vue';\n\ntest('override initialState ', async ({ mount }) => {\n  const component = await mount<HooksConfig>(Store, {\n    hooksConfig: {\n      store: { name: 'override initialState' }\n    }\n  });\n  await expect(component).toContainText('override initialState');\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"how-do-i-access-the-components-methods-or-its-instance",children:"How do I access the component's methods or its instance?"}),"\n",(0,o.jsx)(n.p,{children:"Accessing a component's internal methods or its instance within test code is neither recommended nor supported. Instead, focus on observing and interacting with the component from a user's perspective, typically by clicking or verifying if something is visible on the page. Tests become less fragile and more valuable when they avoid interacting with internal implementation details, such as the component instance or its methods. Keep in mind that if a test fails when run from a user\u2019s perspective, it likely means the automated test has uncovered a genuine bug in your code."})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},4562:(e,n,t)=>{t.d(n,{A:()=>l});var o=t(4848),s=t(6540),a=function(){return a=Object.assign||function(e){for(var n,t=1,o=arguments.length;t<o;t++)for(var s in n=arguments[t])Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s]);return e},a.apply(this,arguments)};var r=s.forwardRef((function(e,n){var t=s.useState(!1),o=t[0],r=t[1],i=s.useState(!1),l=i[0],c=i[1],d=encodeURIComponent(e.id),p="string"==typeof e.playlistCoverId?encodeURIComponent(e.playlistCoverId):null,u=e.title,h=e.poster||"hqdefault",m="&".concat(e.params)||0,g=e.muted?"&mute=1":"",x=e.announce||"Watch",j=e.webp?"webp":"jpg",f=e.webp?"vi_webp":"vi",v=e.thumbnail||(e.playlist?"https://i.ytimg.com/".concat(f,"/").concat(p,"/").concat(h,".").concat(j):"https://i.ytimg.com/".concat(f,"/").concat(d,"/").concat(h,".").concat(j)),w=e.noCookie;w=e.cookie?"https://www.youtube.com":"https://www.youtube-nocookie.com";var y=e.playlist?"".concat(w,"/embed/videoseries?autoplay=1").concat(g,"&list=").concat(d).concat(m):"".concat(w,"/embed/").concat(d,"?autoplay=1&state=1").concat(g).concat(m),b=e.activatedClass||"lyt-activated",k=e.adNetwork||!1,C=e.aspectHeight||9,A=e.aspectWidth||16,N=e.iframeClass||"",P=e.playerClass||"lty-playbtn",S=e.wrapperClass||"yt-lite",H=e.onIframeAdded||function(){},R=e.rel?"prefetch":"preload",T=e.containerElement||"article";return s.useEffect((function(){l&&H()}),[l]),s.createElement(s.Fragment,null,s.createElement("link",{rel:R,href:v,as:"image"}),s.createElement(s.Fragment,null,o&&s.createElement(s.Fragment,null,s.createElement("link",{rel:"preconnect",href:w}),s.createElement("link",{rel:"preconnect",href:"https://www.google.com"}),k&&s.createElement(s.Fragment,null,s.createElement("link",{rel:"preconnect",href:"https://static.doubleclick.net"}),s.createElement("link",{rel:"preconnect",href:"https://googleads.g.doubleclick.net"})))),s.createElement(T,{onPointerOver:function(){o||r(!0)},onClick:function(){l||c(!0)},className:"".concat(S," ").concat(l?b:""),"data-title":u,style:a({backgroundImage:"url(".concat(v,")")},{"--aspect-ratio":"".concat(C/A*100,"%")})},s.createElement("button",{type:"button",className:P,"aria-label":"".concat(x," ").concat(u)}),l&&s.createElement("iframe",{ref:n,className:N,title:u,width:"560",height:"315",frameBorder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowFullScreen:!0,src:y})))}));const i="videoContainer_NvH5";const l=function({id:e,title:n,thumbnail:t}){return(0,o.jsx)("div",{className:i,children:(0,o.jsx)(r,{thumbnail:t,id:e,params:"autoplay=1&autohide=1&showinfo=0&rel=0",title:n,poster:"maxresdefault",webp:!0})})}}}]);